#ifndef SGP_VOBJECT_BLITTERS_32
#define SGP_VOBJECT_BLITTERS_32

#include "VObject.h"
#include "VSurface.h"
#include <cstdint>
struct SDL_Texture;


template<typename T>
struct Blitter
{
protected:
	//
	// Blitting parameters generated by ParseArgs
	//
	mutable T *                   DstPtr;
	mutable std::uint8_t const *  SrcPtr;
	mutable int                   LeftSkip;
	mutable int                   RightSkip;
	mutable int                   BottomSkip;
	mutable int                   LineSkip;
	mutable int                   BlitLength;
	mutable int                   BlitHeight;

protected:
	SDL_Texture *            texture{ nullptr };

	// Returns false if we can skip blitting because we are
	// outside the clipping rect.
	bool ParseArgs() const;

public:
	//
	// Input arguments
	//
	T *                      buffer;
	int                      pitch;
	std::uint16_t            srcObjectIndex;
	SGPVObject const *       srcVObject;
	int                      x;
	int                      y;
	SGPRect const *          clipregion{ nullptr };

	T                        Foreground;         // Only used by MonoShadow
	T                        Background;         // Only used by MonoShadow
	union {
	T                        Shadow;             // Only used by MonoShadow
	T                        OutlineColor;       // Only used by Outline
	};

	// This value if of interest to MPrint and can easily be computed by
	// ParseArgs. This saves two function calls in MPrintCommon().
	mutable int              adjustedSrcWidth;

	Blitter() = default;
	Blitter(Blitter const&) = delete;
	Blitter & operator=(Blitter const&) = delete;
	Blitter(SGPVSurface *);
	Blitter(SDL_Texture *);
	~Blitter();

	// Previously many blitters came in two versions, one for clipped blits
	// and one for blits without. That's no longer the case with the new
	// blitters; if you want unrestricted blits pass in null for the
	// clipregion field (the default value).
	//
	// The old blitters had only the non-clipped version of OutlineShadow
	// implemented.

	void MonoShadow() const;
	void Outline() const;
	void OutlineShadow() const;
	void Transparent() const;
};


// Somewhat fast RGB565 to RGBA32(same as ABGR8888 on little-endian CPUs) conversion routine.
constexpr std::uint32_t RGBA32(std::uint16_t const RGB565)
{
	constexpr std::uint8_t RB5[32] {0,9,17,25,33,42,50,58,66,75,83,91,99,107,116,124,132,140,149,157,165,173,181,190,198,206,214,223,231,239,247,255};
	constexpr std::uint8_t G6[64]  {0,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,90,94,98,102,106,110,114,118,122,126,130,134,138,142,146,150,154,158,162,166,170,175,179,183,187,191,195,199,203,207,211,215,219,223,227,231,235,239,243,247,251,255};
	return
		RB5[RGB565 & 0x1f] |               // red
		(G6[(RGB565 >> 5) & 0x3f] << 8) |  // green
		(RB5[(RGB565 >> 11)] << 16) |      // blue
		(255 << 24);                       // alpha
};
static_assert(RGBA32(0x6dcc) == 0xff6bbb63);
static_assert(RGBA32(0x4a47) == 0xff4b493a);

#endif
